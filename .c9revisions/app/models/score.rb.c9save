{"ts":1368983921214,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"class Score < ActiveRecord::Base\n  belongs_to :user\n  belongs_to :leaderboard\n  attr_accessible :metadata, :display_string, :user_id\n  attr_accessor :rank\n\n  @@enable_user_rank = true\n\n\n  def value=(v)\n    self.sort_value = v\n    self.sort_value *= -1 if leaderboard.is_low_value?\n    v\n  end\n\n  def value\n    v = sort_value\n    v *= -1 if leaderboard.is_low_value?\n    v\n  end\n\n  module Scopes\n    def since(t = nil)\n      t ? where(\"created_at >= :created_at\", {:created_at => t}) : scoped\n    end\n  end\n  extend Scopes\n\n  class << self\n\n    # Apply something here that makes the time switch only every 10 minutes or so to help\n    # caching.\n    def time_boundary_for_frame(frame)\n      boundary = case frame\n        when 'today' then Time.now - 1.day\n        when 'this_week' then Time.now - 1.week\n        when 'all_time' then nil\n      end\n      boundary\n    end\n\n    # Put composite index on leaderboard_id, user_id, created_at, sort_value DESC for this one.\n    def best_for(frame, leaderboard_id, user_id)\n      best_cond = [\"leaderboard_id = ? AND user_id = ?\", leaderboard_id, user_id]\n\n      since = time_boundary_for_frame(frame)\n      if since\n        best_cond[0] << \" AND created_at > ?\"\n        best_cond << since\n      end\n      best_score = where(best_cond).order(\"sort_value DESC\").limit(1)[0]\n\n      if best_score\n        if @@enable_user_rank\n          rank_cond = [\"leaderboard_id = ?\", leaderboard_id]\n          if since\n            rank_cond[0] << \" AND created_at > ?\"\n            rank_cond << since\n          end\n          rank_cond[0] << \" AND sort_value > ?\"\n          rank_cond << best_score.sort_value\n          sanitized_rank_cond = ActiveRecord::Base.send(:sanitize_sql_array, rank_cond)\n          best_score.rank = connection.execute(\"select count(*) from (select * from scores where #{sanitized_rank_cond} group by user_id) t\").first[0] + 1\n        end\n      end\n\n      best_score\n    end\n\n    # Who knows what the index strategy should look like for this one.\n    # Could use the union hack here:\n    # http://www.xaprb.com/blog/2006/12/07/how-to-select-the-firstleastmax-row-per-group-in-sql/\n    #\n    # Note: the timestamp in the query will always break query cache!  Bad!  Use some modulo\n    # on time.\n    #\n    # Cap number per page at 25 for now.\n    #\n    # Notes on this crazy query: The last group by user_id is necessary\n    # because, technically, two scores can be submitted at the same time, for\n    # the same user, with the same value, and these are the columns that we use to\n    # join scores on itself.\n    def bests_for(frame, leaderboard_id, opts = {})\n      page_num     = (opts[:page_num] && opts[:page_num].to_i) || 1\n      num_per_page = (opts[:num_per_page] && opts[:num_per_page].to_i) || 25\n      num_per_page > 25 && num_per_page = 25\n\n      since = case frame\n        when 'today' then Time.now - 1.day\n        when 'this_week' then Time.now - 1.week\n        when 'all_time' then nil\n      end\n\n      leaderboard_cond = ActiveRecord::Base.send(:sanitize_sql_array, [\"leaderboard_id = ?\", leaderboard_id])\n      created_cond = since && ActiveRecord::Base.send(:sanitize_sql_array, [\"created_at > ?\", since])\n\n      query =<<-END\n      select scores.* from (\n        select t1.*, min(created_at) as first_time from (\n          select leaderboard_id, user_id, max(sort_value) as max_val from scores\n          where #{leaderboard_cond} #{created_cond ? \"AND \" + created_cond : ''}\n          group by user_id\n          order by max_val DESC\n          limit #{num_per_page.to_i}\n          offset #{(page_num.to_i - 1) * num_per_page.to_i}\n        ) t1\n        left join scores x on t1.leaderboard_id=x.leaderboard_id and t1.user_id=x.user_id and t1.max_val=x.sort_value\n        where x.#{leaderboard_cond} #{created_cond ? \"AND x.\" + created_cond : ''}\n        group by x.user_id\n      ) t2\n      left join scores on t2.leaderboard_id=scores.leaderboard_id AND t2.user_id=scores.user_id AND t2.max_val=scores.sort_value AND t2.first_time=scores.created_at\n      GROUP BY user_id\n      ORDER BY scores.sort_value DESC\n      END\n\n      query.gsub!(/\\s+/, \" \")\n      scores = Score.find_by_sql(query)\n      start_rank = ((page_num - 1) * num_per_page) + 1\n      scores.inject(start_rank) {|x,y| y.rank = x; x+=1; x}\n      scores\n    end\n  end\n\n  def is_better_than?(other_score)\n    sort_value > other_score.sort_value\n  end\n\n  private\n\nend\n\n"]],"start1":0,"start2":0,"length1":0,"length2":4400}]],"length":4400}
